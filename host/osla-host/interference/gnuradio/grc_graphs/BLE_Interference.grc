options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: GFSK
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: BLE_Interference_test
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: BLE_fd
  id: variable
  parameters:
    comment: ''
    value: '250000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 140.0]
    rotation: 0
    state: true
- name: BLE_sym_length
  id: variable
  parameters:
    comment: ''
    value: '.000001'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [288, 140.0]
    rotation: 0
    state: enabled
- name: CH_gain
  id: variable
  parameters:
    comment: ''
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 100.0]
    rotation: 0
    state: true
- name: ES_Ni
  id: variable
  parameters:
    comment: ''
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [544, 148.0]
    rotation: 0
    state: true
- name: F_IF
  id: variable
  parameters:
    comment: ''
    value: '595238'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [768, 244.0]
    rotation: 0
    state: true
- name: F_Of
  id: variable
  parameters:
    comment: ''
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [792, 172.0]
    rotation: 0
    state: true
- name: Pr
  id: variable
  parameters:
    comment: ''
    value: '-90'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [544, 212.0]
    rotation: 0
    state: true
- name: TX_ID
  id: variable
  parameters:
    comment: ''
    value: '"addr=192.168.10.2"'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1024, 172.0]
    rotation: 0
    state: true
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '20000000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [768, 36.0]
    rotation: 0
    state: enabled
- name: sensitivity
  id: variable
  parameters:
    comment: ''
    value: 2*math.pi*BLE_fd/samp_rate
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 76.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '20000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 212.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0_0
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '20000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 316.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0_1
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '20000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 412.0]
    rotation: 0
    state: true
- name: blocks_freqshift_cc_0
  id: blocks_freqshift_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    freq: F_IF-F_Of
    maxoutbuf: '0'
    minoutbuf: '0'
    sample_rate: samp_rate
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 308.0]
    rotation: 0
    state: true
- name: blocks_message_debug_0
  id: blocks_message_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    en_uvec: 'True'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [112, 560.0]
    rotation: 0
    state: true
- name: digital_gfsk_mod_0_0_0
  id: digital_gfsk_mod
  parameters:
    affinity: ''
    alias: ''
    bt: '0.5'
    comment: ''
    do_unpack: 'False'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: round(BLE_sym_length*samp_rate)
    sensitivity: sensitivity
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 212.0]
    rotation: 0
    state: true
- name: digital_gfsk_mod_0_0_0_0
  id: digital_gfsk_mod
  parameters:
    affinity: ''
    alias: ''
    bt: '0.5'
    comment: ''
    do_unpack: 'False'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: round(BLE_sym_length*samp_rate)
    sensitivity: sensitivity
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 316.0]
    rotation: 0
    state: true
- name: digital_gfsk_mod_0_0_0_1
  id: digital_gfsk_mod
  parameters:
    affinity: ''
    alias: ''
    bt: '0.5'
    comment: ''
    do_unpack: 'False'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: round(BLE_sym_length*samp_rate)
    sensitivity: sensitivity
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 412.0]
    rotation: 0
    state: true
- name: epy_block_0
  id: epy_block
  parameters:
    Es_Ni: '-10'
    F_of: -F_Of
    Pr: '-90'
    _source_code: "\"\"\"\nAuthor: Samuel Nolan\nDescription:\nTakes in three noise\
      \ sources on the input and randomly adds them together\naccording to a poisson\
      \ distribution. Internally normalizes inband noise power\nfrom settings and\
      \ then multiplies the amplitude according to a log normal distribution.\n\"\"\
      \"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Embedded Python Block Noise Controller\"\"\"\n\n    def __init__(self, sampling_rate\
      \ = 32000, noise_rate = 1.0, noise_length = 1.0, Es_Ni = 0, Pr = 0, F_of = 0):\
      \  # only default arguments here\n        \"\"\"\n        Parameters:\n    \
      \    sampling rate (Hz): Needed to calculate length of noise frame and wait\
      \ frame\n        noise_rate (arrivals/second): noise packet rate /s (can overlap\
      \ up to 3 packets)\n        noise length (seconds): length of interference packet\
      \ (if too large may just overlap constantly)\n        Es_Ni(dBm): Desired Es/Ni\
      \ (Es is hard coded internally)\n        Pr(dB): estimate of received power\
      \ from sending a digital normalized signal \n        F_of (Hz): offset of OSLA\
      \ from center of BLE noise (-+). Used in in-band normalization calculation.\n\
      \        analog_gain (dB): To prevent saturation, set analog gain accordingly\n\
      \        \"\"\"\n\n        gr.sync_block.__init__(\n            self,\n    \
      \        name='Noise Controller',   # will show up in GRC\n            in_sig=[np.complex64,np.complex64,np.complex64],\n\
      \            out_sig=[np.complex64]\n        )\n \n        \n        #n_counters[0]:\
      \ state of interferer\n        #n_counters[1]: noise clk(how long its been on)\n\
      \        #n_counters[2]: gain of interferer (decided on log normal distribution)\n\
      \        #n_counters[3]: last n_samples of a frame that should include noise\n\
      \        self.n_counters = np.array([[False,0,1.0,0], [False,0,1.0,0], [False,0,1.0,0]])\n\
      \n        #######################\n        #Calculate desired P_I#\n       \
      \ #######################\n\n        #Bandwidth of OSLA signal hardcoded here\n\
      \        #336 samples/chip\n        #32 chips/symbol\n        #200000000 samples/second\n\
      \        #W = 1/R\n        Ts = 336*32/200000000\n        BW = 2/Ts\n      \
      \  \n        #calculate desired interference power to be used in log normal\
      \ distribution\n\n        Es = -171\n        P_I = Es-Es_Ni + 10*np.log10(BW)\n\
      \        self.mu = P_I - 10*np.log10(noise_rate) - 10*np.log10(noise_length)\n\
      \n        self.Pr = Pr\n        \n        ########################\n       \
      \ #Normalize In-Band Gain#\n        ########################\n\n        #generate\
      \ normalizer gain from LUT\n        file_path = '/home/samnolan/OSLA_research/OSLA/bpsk/interference/MATLAB/BLEwaveform/BLE_PSD.csv'\n\
      \        try:\n            PSD = np.genfromtxt(file_path,delimiter=',', dtype=np.double)\n\
      \        except FileNotFoundError:\n            print(f\"Error: File not found\
      \ at {file_path}\")\n\n\n        fbin_width = 100\n        #define gain to have\
      \ normalized in band power\n        #With this gain, we will have normalized\
      \ digital power and receive ~Pr that we measured\n        PSD_i_low  = int(np.round((len(PSD)/2)\
      \ + (F_of/fbin_width) - (BW/fbin_width)/2) + 1)\n        PSD_i_high = int(np.round((len(PSD)/2)\
      \ + (F_of/fbin_width) + (BW/fbin_width)/2))    \n\n        self.G = np.sqrt(1/(fbin_width*np.sum(PSD[PSD_i_low:PSD_i_high,0])))\n\
      \n        self.scale = 0\n        \n        ##############################\n\
      \        #set up interferer parameters#\n        ##############################\n\
      \        #phase shift\n        self.theta = np.random.uniform(size=len(self.n_counters))*2j*np.pi\n\
      \n        self.sampling_rate = sampling_rate\n        self.rate = noise_rate\n\
      \        self.noise_length = noise_length\n\n        self.noise_frame = np.round((sampling_rate*self.noise_length),0)\n\
      \n        self.arrival_clk = 0\n        self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \        \n        self.idx = 0\n        self.starved = False\n        ########################\n\
      \n        self.DebugPortName = 'Debug'\n        self.message_port_register_out(pmt.intern(self.DebugPortName))\n\
      \n\n    def work(self, input_items, output_items):\n        self.arrival_clk\
      \ = self.arrival_clk + len(output_items[0])\n        self.idx = next((i for\
      \ i,j in enumerate(self.n_counters) if not j[0]),None)\n        if (self.idx\
      \ == None) and (self.arrival_clk >= self.wait_frame):\n            self.starved\
      \ = True\n        '''\n        #use this to send messages from the debug port\n\
      \            PMT_msg = pmt.from_bool(self.state)\n            self.message_port_pub(pmt.intern(self.DebugPortName),\
      \ PMT_msg)\n        '''\n\n        #run arrival clk and signal when packet should\
      \ start transmitting\n        if ((self.arrival_clk >= self.wait_frame) and\
      \ not self.starved):\n            self.arrival_clk = self.arrival_clk - self.wait_frame\n\
      \            self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \            #Mark Interferer to start\n            self.n_counters[self.idx][0]\
      \ = True\n            #generate gain value from parameters\n            P =\
      \ np.random.normal(loc=self.mu, scale=self.scale)\n            self.n_counters[self.idx][2]\
      \ = self.G*np.sqrt(10**((P-self.Pr)/10))\n            #generate new phase offset\n\
      \            self.theta[self.idx] = np.random.uniform()*2j*np.pi\n         \
      \   self.n_counters[self.idx][3] = self.arrival_clk\n            \n        \
      \    \n            #if next wait_frame occurs in same window\n            self.idx\
      \ = next((i for i,j in enumerate(self.n_counters) if not j[0]),None)\n     \
      \       if ((self.arrival_clk >= self.wait_frame) and (self.idx != None)):\n\
      \                self.arrival_clk = self.arrival_clk - self.wait_frame\n   \
      \             self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \                #Mark Interferer to start\n                self.n_counters[self.idx][0]\
      \ = True\n                #generate gain value from parameters\n           \
      \     P = np.random.normal(loc=self.mu, scale=self.scale)\n                self.n_counters[self.idx][2]\
      \ = self.G*np.sqrt(10**((P-self.Pr)/10))\n                #generate new phase\
      \ offset\n                self.theta[self.idx] = np.random.uniform()*2j*np.pi\n\
      \                self.n_counters[self.idx][3] = self.arrival_clk\n\n       \
      \         #if all three interferers occur in the same window\n             \
      \   self.idx = next((i for i,j in enumerate(self.n_counters) if not j[0]),None)\n\
      \                if ((self.arrival_clk >= self.wait_frame) and (self.idx !=\
      \ None)):\n                    self.arrival_clk = self.arrival_clk - self.wait_frame\n\
      \                    self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \                    #Mark Interferer to start\n                    self.n_counters[self.idx][0]\
      \ = True\n                    #generate gain value from parameters\n       \
      \             P = np.random.normal(loc=self.mu, scale=self.scale)\n        \
      \            self.n_counters[self.idx][2] = self.G*np.sqrt(10**((P-self.Pr)/10))\n\
      \                    #generate new phase offset\n                    self.theta[self.idx]\
      \ = np.random.uniform()*2j*np.pi\n                    self.n_counters[self.idx][3]\
      \ = self.arrival_clk\n            \n            #PMT_msg = pmt.to_pmt(self.wait_frame)\n\
      \            #self.message_port_pub(pmt.intern(self.DebugPortName), PMT_msg)\n\
      \n        #If we are starved we want to start noise immediately and also reset\
      \ the arrival clock to prevent error buildup\n        if ((self.idx != None)\
      \ and self.starved):\n            self.arrival_clk = len(output_items[0])\n\
      \            self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \            #Mark Interferer to start\n            self.n_counters[self.idx][0]\
      \ = True\n            #generate gain value from parameters\n            P =\
      \ np.random.normal(loc=self.mu, scale=self.scale)\n            self.n_counters[self.idx][2]\
      \ = self.G*np.sqrt(10**((P-self.Pr)/10))\n            #generate new phase offset\n\
      \            self.theta[self.idx] = np.random.uniform()*2j*np.pi\n         \
      \   self.starved = False\n\n            \n        output_items[0][:] = 0\n \
      \       for i in range(len(self.n_counters)):\n            if(self.n_counters[i][0]):\n\
      \n                if(self.n_counters[i][3] != 0):\n                    self.n_counters[i][1]\
      \ = self.n_counters[i][1] + self.n_counters[i][3]\n                    output_items[0][-int(self.n_counters[i][3]):]\
      \ = output_items[0][-int(self.n_counters[i][3]):] + self.n_counters[i][2]*input_items[i][-int(self.n_counters[i][3]):]*np.exp(self.theta[i])\n\
      \                    self.n_counters[i][3] = 0\n                else:\n    \
      \                self.n_counters[i][1] = self.n_counters[i][1] + len(output_items[0])\n\
      \                    \n                    if(self.n_counters[i][1] > self.noise_frame):\n\
      \                        end_n_elem = len(output_items[0]) - (self.n_counters[i][1]\
      \ - self.noise_frame)\n                        output_items[0][:int(end_n_elem)]\
      \ = output_items[0][:int(end_n_elem)] + self.n_counters[i][2]*input_items[i][:int(end_n_elem)]*np.exp(self.theta[i])\n\
      \                        self.n_counters[i][0] = False\n                   \
      \     self.n_counters[i][1] = 0\n                    else:\n               \
      \         output_items[0][:] = output_items[0][:] + self.n_counters[i][2]*input_items[i]*np.exp(self.theta[i])\n\
      \n                \n\n        if(abs(output_items[0][0]) > 1):\n           \
      \ PMT_msg = pmt.string_to_symbol(\"Warning: USRP is saturated, please edit analog\
      \ gain in flowgraph\")\n            self.message_port_pub(pmt.intern(self.DebugPortName),\
      \ PMT_msg)\n        #    return -1\n        return len(output_items[0][:])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_length: '.002'
    noise_rate: '200'
    sampling_rate: samp_rate
  states:
    _io_cache: ('Noise Controller', 'blk', [('sampling_rate', '32000'), ('noise_rate',
      '1.0'), ('noise_length', '1.0'), ('Es_Ni', '0'), ('Pr', '0'), ('F_of', '0')],
      [('0', 'complex', 1), ('1', 'complex', 1), ('2', 'complex', 1)], [('0', 'complex',
      1), ('Debug', 'message', 1)], 'Embedded Python Block Noise Controller', ['Pr',
      'noise_length', 'sampling_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 292.0]
    rotation: 0
    state: true
- name: import_0
  id: import
  parameters:
    alias: ''
    comment: ''
    imports: import math
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 108.0]
    rotation: 0
    state: true
- name: uhd_usrp_sink_0
  id: uhd_usrp_sink
  parameters:
    affinity: ''
    alias: ''
    ant0: '"TX/RX"'
    ant1: '"TX/RX"'
    ant10: '"TX/RX"'
    ant11: '"TX/RX"'
    ant12: '"TX/RX"'
    ant13: '"TX/RX"'
    ant14: '"TX/RX"'
    ant15: '"TX/RX"'
    ant16: '"TX/RX"'
    ant17: '"TX/RX"'
    ant18: '"TX/RX"'
    ant19: '"TX/RX"'
    ant2: '"TX/RX"'
    ant20: '"TX/RX"'
    ant21: '"TX/RX"'
    ant22: '"TX/RX"'
    ant23: '"TX/RX"'
    ant24: '"TX/RX"'
    ant25: '"TX/RX"'
    ant26: '"TX/RX"'
    ant27: '"TX/RX"'
    ant28: '"TX/RX"'
    ant29: '"TX/RX"'
    ant3: '"TX/RX"'
    ant30: '"TX/RX"'
    ant31: '"TX/RX"'
    ant4: '"TX/RX"'
    ant5: '"TX/RX"'
    ant6: '"TX/RX"'
    ant7: '"TX/RX"'
    ant8: '"TX/RX"'
    ant9: '"TX/RX"'
    bw0: '160000000'
    bw1: '0'
    bw10: '0'
    bw11: '0'
    bw12: '0'
    bw13: '0'
    bw14: '0'
    bw15: '0'
    bw16: '0'
    bw17: '0'
    bw18: '0'
    bw19: '0'
    bw2: '0'
    bw20: '0'
    bw21: '0'
    bw22: '0'
    bw23: '0'
    bw24: '0'
    bw25: '0'
    bw26: '0'
    bw27: '0'
    bw28: '0'
    bw29: '0'
    bw3: '0'
    bw30: '0'
    bw31: '0'
    bw4: '0'
    bw5: '0'
    bw6: '0'
    bw7: '0'
    bw8: '0'
    bw9: '0'
    center_freq0: '2400000000'
    center_freq1: '0'
    center_freq10: '0'
    center_freq11: '0'
    center_freq12: '0'
    center_freq13: '0'
    center_freq14: '0'
    center_freq15: '0'
    center_freq16: '0'
    center_freq17: '0'
    center_freq18: '0'
    center_freq19: '0'
    center_freq2: '0'
    center_freq20: '0'
    center_freq21: '0'
    center_freq22: '0'
    center_freq23: '0'
    center_freq24: '0'
    center_freq25: '0'
    center_freq26: '0'
    center_freq27: '0'
    center_freq28: '0'
    center_freq29: '0'
    center_freq3: '0'
    center_freq30: '0'
    center_freq31: '0'
    center_freq4: '0'
    center_freq5: '0'
    center_freq6: '0'
    center_freq7: '0'
    center_freq8: '0'
    center_freq9: '0'
    clock_rate: 0e0
    clock_source0: external
    clock_source1: ''
    clock_source2: ''
    clock_source3: ''
    clock_source4: ''
    clock_source5: ''
    clock_source6: ''
    clock_source7: ''
    comment: ''
    dev_addr: TX_ID
    dev_args: ''
    gain0: CH_gain
    gain1: '0'
    gain10: '0'
    gain11: '0'
    gain12: '0'
    gain13: '0'
    gain14: '0'
    gain15: '0'
    gain16: '0'
    gain17: '0'
    gain18: '0'
    gain19: '0'
    gain2: '0'
    gain20: '0'
    gain21: '0'
    gain22: '0'
    gain23: '0'
    gain24: '0'
    gain25: '0'
    gain26: '0'
    gain27: '0'
    gain28: '0'
    gain29: '0'
    gain3: '0'
    gain30: '0'
    gain31: '0'
    gain4: '0'
    gain5: '0'
    gain6: '0'
    gain7: '0'
    gain8: '0'
    gain9: '0'
    gain_type0: default
    gain_type1: default
    gain_type10: default
    gain_type11: default
    gain_type12: default
    gain_type13: default
    gain_type14: default
    gain_type15: default
    gain_type16: default
    gain_type17: default
    gain_type18: default
    gain_type19: default
    gain_type2: default
    gain_type20: default
    gain_type21: default
    gain_type22: default
    gain_type23: default
    gain_type24: default
    gain_type25: default
    gain_type26: default
    gain_type27: default
    gain_type28: default
    gain_type29: default
    gain_type3: default
    gain_type30: default
    gain_type31: default
    gain_type4: default
    gain_type5: default
    gain_type6: default
    gain_type7: default
    gain_type8: default
    gain_type9: default
    len_tag_name: '""'
    lo_export0: 'False'
    lo_export1: 'False'
    lo_export10: 'False'
    lo_export11: 'False'
    lo_export12: 'False'
    lo_export13: 'False'
    lo_export14: 'False'
    lo_export15: 'False'
    lo_export16: 'False'
    lo_export17: 'False'
    lo_export18: 'False'
    lo_export19: 'False'
    lo_export2: 'False'
    lo_export20: 'False'
    lo_export21: 'False'
    lo_export22: 'False'
    lo_export23: 'False'
    lo_export24: 'False'
    lo_export25: 'False'
    lo_export26: 'False'
    lo_export27: 'False'
    lo_export28: 'False'
    lo_export29: 'False'
    lo_export3: 'False'
    lo_export30: 'False'
    lo_export31: 'False'
    lo_export4: 'False'
    lo_export5: 'False'
    lo_export6: 'False'
    lo_export7: 'False'
    lo_export8: 'False'
    lo_export9: 'False'
    lo_source0: internal
    lo_source1: internal
    lo_source10: internal
    lo_source11: internal
    lo_source12: internal
    lo_source13: internal
    lo_source14: internal
    lo_source15: internal
    lo_source16: internal
    lo_source17: internal
    lo_source18: internal
    lo_source19: internal
    lo_source2: internal
    lo_source20: internal
    lo_source21: internal
    lo_source22: internal
    lo_source23: internal
    lo_source24: internal
    lo_source25: internal
    lo_source26: internal
    lo_source27: internal
    lo_source28: internal
    lo_source29: internal
    lo_source3: internal
    lo_source30: internal
    lo_source31: internal
    lo_source4: internal
    lo_source5: internal
    lo_source6: internal
    lo_source7: internal
    lo_source8: internal
    lo_source9: internal
    maxoutbuf: '0'
    minoutbuf: '0'
    nchan: '1'
    num_mboards: '1'
    otw: ''
    samp_rate: samp_rate
    sd_spec0: ''
    sd_spec1: ''
    sd_spec2: ''
    sd_spec3: ''
    sd_spec4: ''
    sd_spec5: ''
    sd_spec6: ''
    sd_spec7: ''
    show_lo_controls: 'False'
    start_time: '-1.0'
    stream_args: ''
    stream_chans: '[]'
    sync: sync
    time_source0: ''
    time_source1: ''
    time_source2: ''
    time_source3: ''
    time_source4: ''
    time_source5: ''
    time_source6: ''
    time_source7: ''
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1016, 244.0]
    rotation: 0
    state: true

connections:
- [analog_random_source_x_0, '0', digital_gfsk_mod_0_0_0, '0']
- [analog_random_source_x_0_0, '0', digital_gfsk_mod_0_0_0_0, '0']
- [analog_random_source_x_0_1, '0', digital_gfsk_mod_0_0_0_1, '0']
- [blocks_freqshift_cc_0, '0', uhd_usrp_sink_0, '0']
- [digital_gfsk_mod_0_0_0, '0', epy_block_0, '0']
- [digital_gfsk_mod_0_0_0_0, '0', epy_block_0, '1']
- [digital_gfsk_mod_0_0_0_1, '0', epy_block_0, '2']
- [epy_block_0, '0', blocks_freqshift_cc_0, '0']
- [epy_block_0, Debug, blocks_message_debug_0, print]

metadata:
  file_format: 1
