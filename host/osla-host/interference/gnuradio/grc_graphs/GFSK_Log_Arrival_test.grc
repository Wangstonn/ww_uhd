options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: GFSK
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: BLE_Interference_test
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: BLE_fd
  id: variable
  parameters:
    comment: ''
    value: '250000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [664, 12.0]
    rotation: 0
    state: true
- name: BLE_sym_length
  id: variable
  parameters:
    comment: ''
    value: '.000001'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [296, 12.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '16000000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [184, 12]
    rotation: 0
    state: enabled
- name: sensitivity
  id: variable
  parameters:
    comment: ''
    value: 2*math.pi*BLE_fd/samp_rate
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [432, 12.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '2000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 212.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0_0
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '2000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 316.0]
    rotation: 0
    state: true
- name: analog_random_source_x_0_1
  id: analog_random_source_x
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    max: '2'
    maxoutbuf: '0'
    min: '0'
    minoutbuf: '0'
    num_samps: '2000'
    repeat: 'True'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 412.0]
    rotation: 0
    state: true
- name: blocks_message_debug_0
  id: blocks_message_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    en_uvec: 'True'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [616, 536.0]
    rotation: 0
    state: true
- name: blocks_throttle_0
  id: blocks_throttle
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [864, 324.0]
    rotation: 0
    state: true
- name: blocks_throttle_0_0
  id: blocks_throttle
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: int
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [944, 492.0]
    rotation: 0
    state: true
- name: digital_gfsk_mod_0_0_0
  id: digital_gfsk_mod
  parameters:
    affinity: ''
    alias: ''
    bt: '0.5'
    comment: ''
    do_unpack: 'False'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: round(BLE_sym_length*samp_rate)
    sensitivity: sensitivity
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 212.0]
    rotation: 0
    state: true
- name: digital_gfsk_mod_0_0_0_0
  id: digital_gfsk_mod
  parameters:
    affinity: ''
    alias: ''
    bt: '0.5'
    comment: ''
    do_unpack: 'False'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: round(BLE_sym_length*samp_rate)
    sensitivity: sensitivity
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 316.0]
    rotation: 0
    state: true
- name: digital_gfsk_mod_0_0_0_1
  id: digital_gfsk_mod
  parameters:
    affinity: ''
    alias: ''
    bt: '0.5'
    comment: ''
    do_unpack: 'False'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: round(BLE_sym_length*samp_rate)
    sensitivity: sensitivity
    verbose: 'False'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 412.0]
    rotation: 0
    state: true
- name: epy_block_0
  id: epy_block
  parameters:
    Es_Ni: '-10'
    F_of: '0'
    Pr: '-90'
    _source_code: "\"\"\"\nAuthor: Samuel Nolan\nDescription:\nTakes in three noise\
      \ sources on the input and randomly adds them together\naccording to a poisson\
      \ distribution. Internally normalizes inband noise power\nfrom settings and\
      \ then multiplies the amplitude according to a log normal distribution.\n\"\"\
      \"\n\nimport numpy as np\nfrom gnuradio import gr\nimport pmt\n\n\nclass blk(gr.sync_block):\
      \  # other base classes are basic_block, decim_block, interp_block\n    \"\"\
      \"Embedded Python Block Noise Controller\"\"\"\n\n    def __init__(self, sampling_rate\
      \ = 32000, noise_rate = 1.0, noise_length = 1.0, Es_Ni = 0, Pr = 0, F_of = 0):\
      \  # only default arguments here\n        \"\"\"\n        Parameters:\n    \
      \    sampling rate (Hz): Needed to calculate length of noise frame and wait\
      \ frame\n        noise_rate (arrivals/second): noise packet rate /s (can overlap\
      \ up to 3 packets)\n        noise length (seconds): length of interference packet\
      \ (if too large may just overlap constantly)\n        Es_Ni(dBm): Desired Es/Ni\
      \ (Es is hard coded internally)\n        Pr(dB): estimate of received power\
      \ from sending a digital normalized signal \n        F_of (Hz): offset of OSLA\
      \ from center of BLE noise (-+). Used in in-band normalization calculation.\n\
      \        \"\"\"\n\n        gr.sync_block.__init__(\n            self,\n    \
      \        name='Noise Controller',   # will show up in GRC\n            in_sig=[np.complex64,np.complex64,np.complex64],\n\
      \            out_sig=[np.complex64,np.int32]\n        )\n \n        \n     \
      \   #n_counters[0]: state of interferer\n        #n_counters[1]: noise clk(how\
      \ long its been on)\n        #n_counters[2]: gain of interferer (decided on\
      \ log normal distribution)\n        #n_counters[3]: last n_samples of a frame\
      \ that should include noise\n        self.n_counters = np.array([[False,0,1.0,0],\
      \ [False,0,1.0,0], [False,0,1.0,0]])\n\n        #######################\n  \
      \      #Calculate desired P_I#\n        #######################\n\n        #Bandwidth\
      \ of OSLA signal hardcoded here\n        #336 samples/chip\n        #32 chips/symbol\n\
      \        #200000000 samples/second\n        #W = 1/R\n        Ts = 336*32/200000000\n\
      \        BW = 2/Ts\n        \n        #calculate desired interference power\
      \ to be used in log normal distribution\n\n        Es = -171\n        P_I =\
      \ Es-Es_Ni + 10*np.log10(BW)\n        self.mu = P_I - 10*np.log10(noise_rate)\
      \ - 10*np.log10(noise_length)\n\n        self.Pr = Pr\n        \n        ########################\n\
      \        #Normalize In-Band Gain#\n        ########################\n\n    \
      \    #generate normalizer gain from LUT\n        file_path = '/home/samnolan/OSLA_research/OSLA/bpsk/interference/MATLAB/BLEwaveform/BLE_PSD.csv'\n\
      \        try:\n            PSD = np.genfromtxt(file_path,delimiter=',', dtype=np.double)\n\
      \        except FileNotFoundError:\n            print(f\"Error: File not found\
      \ at {file_path}\")\n\n\n        fbin_width = 100\n        #define gain to have\
      \ normalized in band power\n        #With this gain, we will have normalized\
      \ digital power and receive ~Pr that we measured\n        PSD_i_low  = int(np.round((len(PSD)/2)\
      \ + (F_of/fbin_width) - (BW/fbin_width)/2) + 1)\n        PSD_i_high = int(np.round((len(PSD)/2)\
      \ + (F_of/fbin_width) + (BW/fbin_width)/2))    \n\n        self.G = np.sqrt(1/(fbin_width*np.sum(PSD[PSD_i_low:PSD_i_high,0])))\n\
      \        \n        ##############################\n        #set up interferer\
      \ parameters#\n        ##############################\n        #phase shift\n\
      \        self.theta = np.random.uniform(size=len(self.n_counters))*2j*np.pi\n\
      \n        self.sampling_rate = sampling_rate\n        self.rate = noise_rate\n\
      \        self.noise_length = noise_length\n\n        self.noise_frame = np.round((sampling_rate*self.noise_length),0)\n\
      \n        self.arrival_clk = 0\n        self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \        \n        self.idx = 0\n        self.starved = False\n        ########################\n\
      \n        self.DebugPortName = 'Debug'\n        self.message_port_register_out(pmt.intern(self.DebugPortName))\n\
      \n\n    def work(self, input_items, output_items):\n        self.arrival_clk\
      \ = self.arrival_clk + len(output_items[0])\n        self.idx = next((i for\
      \ i,j in enumerate(self.n_counters) if not j[0]),None)\n        if (self.idx\
      \ == None) and (self.arrival_clk >= self.wait_frame):\n            self.starved\
      \ = True\n        '''\n        #use this to send messages from the debug port\n\
      \            PMT_msg = pmt.from_bool(self.state)\n            self.message_port_pub(pmt.intern(self.DebugPortName),\
      \ PMT_msg)\n        '''\n\n        #run arrival clk and signal when packet should\
      \ start transmitting\n        if ((self.arrival_clk >= self.wait_frame) and\
      \ not self.starved):\n            self.arrival_clk = self.arrival_clk - self.wait_frame\n\
      \            self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \            #Mark Interferer to start\n            self.n_counters[self.idx][0]\
      \ = True\n            #generate gain value from parameters\n            P =\
      \ np.random.normal(loc=self.mu, scale=10)\n            self.n_counters[self.idx][2]\
      \ = self.G*np.sqrt(10**((P-self.Pr)/10))\n            #generate new phase offset\n\
      \            self.theta[self.idx] = np.random.uniform()*2j*np.pi\n         \
      \   self.n_counters[self.idx][3] = self.arrival_clk\n            \n        \
      \    \n            #if next wait_frame occurs in same window\n            self.idx\
      \ = next((i for i,j in enumerate(self.n_counters) if not j[0]),None)\n     \
      \       if ((self.arrival_clk >= self.wait_frame) and (self.idx != None)):\n\
      \                self.arrival_clk = self.arrival_clk - self.wait_frame\n   \
      \             self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \                #Mark Interferer to start\n                self.n_counters[self.idx][0]\
      \ = True\n                #generate gain value from parameters\n           \
      \     P = np.random.normal(loc=self.mu, scale=10)\n                self.n_counters[self.idx][2]\
      \ = self.G*np.sqrt(10**((P-self.Pr)/10))\n                #generate new phase\
      \ offset\n                self.theta[self.idx] = np.random.uniform()*2j*np.pi\n\
      \                self.n_counters[self.idx][3] = self.arrival_clk\n\n       \
      \         #if all three interferers occur in the same window\n             \
      \   self.idx = next((i for i,j in enumerate(self.n_counters) if not j[0]),None)\n\
      \                if ((self.arrival_clk >= self.wait_frame) and (self.idx !=\
      \ None)):\n                    self.arrival_clk = self.arrival_clk - self.wait_frame\n\
      \                    self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \                    #Mark Interferer to start\n                    self.n_counters[self.idx][0]\
      \ = True\n                    #generate gain value from parameters\n       \
      \             P = np.random.normal(loc=self.mu, scale=10)\n                \
      \    self.n_counters[self.idx][2] = self.G*np.sqrt(10**((P-self.Pr)/10))\n \
      \                   #generate new phase offset\n                    self.theta[self.idx]\
      \ = np.random.uniform()*2j*np.pi\n                    self.n_counters[self.idx][3]\
      \ = self.arrival_clk\n            \n            #PMT_msg = pmt.to_pmt(self.wait_frame)\n\
      \            #self.message_port_pub(pmt.intern(self.DebugPortName), PMT_msg)\n\
      \n        #If we are starved we want to start noise immediately and also reset\
      \ the arrival clock to prevent error buildup\n        if ((self.idx != None)\
      \ and self.starved):\n            self.arrival_clk = len(output_items[0])\n\
      \            self.wait_frame = round(((-1/self.rate)*np.log(np.random.uniform())*self.sampling_rate))\n\
      \            #Mark Interferer to start\n            self.n_counters[self.idx][0]\
      \ = True\n            #generate gain value from parameters\n            P =\
      \ np.random.normal(loc=self.mu, scale=10)\n            self.n_counters[self.idx][2]\
      \ = self.G*np.sqrt(10**((P-self.Pr)/10))\n            #generate new phase offset\n\
      \            self.theta[self.idx] = np.random.uniform()*2j*np.pi\n         \
      \   self.starved = False\n\n            \n\n        output_items[1][:] = self.wait_frame\n\
      \        output_items[0][:] = 0\n        for i in range(len(self.n_counters)):\n\
      \            if(self.n_counters[i][0]):\n\n                if(self.n_counters[i][3]\
      \ != 0):\n                    self.n_counters[i][1] = self.n_counters[i][1]\
      \ + self.n_counters[i][3]\n                    output_items[0][-int(self.n_counters[i][3]):]\
      \ = output_items[0][-int(self.n_counters[i][3]):] + self.n_counters[i][2]*input_items[i][-int(self.n_counters[i][3]):]*np.exp(self.theta[i])\n\
      \                    self.n_counters[i][3] = 0\n                else:\n    \
      \                self.n_counters[i][1] = self.n_counters[i][1] + len(output_items[0])\n\
      \                    \n                    if(self.n_counters[i][1] > self.noise_frame):\n\
      \                        end_n_elem = len(output_items[0]) - (self.n_counters[i][1]\
      \ - self.noise_frame)\n                        output_items[0][:int(end_n_elem)]\
      \ = output_items[0][:int(end_n_elem)] + self.n_counters[i][2]*input_items[i][:int(end_n_elem)]*np.exp(self.theta[i])\n\
      \                        self.n_counters[i][0] = False\n                   \
      \     self.n_counters[i][1] = 0\n                    else:\n               \
      \         output_items[0][:] = output_items[0][:] + self.n_counters[i][2]*input_items[i]*np.exp(self.theta[i])\n\
      \n                \n\n        if(abs(output_items[0][0]) > 1):\n           \
      \ PMT_msg = pmt.string_to_symbol(\"Warning: USRP is saturated, please edit analog\
      \ gain in flowgraph\")\n            self.message_port_pub(pmt.intern(self.DebugPortName),\
      \ PMT_msg)\n        #    return -1\n        return len(output_items[0][:])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_length: '.002'
    noise_rate: '200'
    sampling_rate: samp_rate
  states:
    _io_cache: ('Noise Controller', 'blk', [('sampling_rate', '32000'), ('noise_rate',
      '1.0'), ('noise_length', '1.0'), ('Es_Ni', '0'), ('Pr', '0'), ('F_of', '0')],
      [('0', 'complex', 1), ('1', 'complex', 1), ('2', 'complex', 1)], [('0', 'complex',
      1), ('1', 'int', 1), ('Debug', 'message', 1)], 'Embedded Python Block Noise
      Controller', ['Pr', 'noise_length', 'sampling_rate'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [480, 292.0]
    rotation: 0
    state: true
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass logging_block(gr.sync_block):\n\
      \    \"\"\"\n    Logs complex input data to a file and stops processing after\
      \ a specified number of samples.\n    Signals the GNU Radio runtime to terminate\
      \ by returning -1 once the sample limit is reached.\n    \"\"\"\n    def __init__(self,\
      \ file_path=\"output.log\", sample_limit=1000):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"Logging Block\",\n            in_sig=[np.complex64],\
      \  # Input: complex data\n            out_sig=[np.complex64]  # Output: complex\
      \ data\n        )\n        self.file_path = file_path\n        self.sample_limit\
      \ = sample_limit\n        self.sample_count = 0\n        self.file = open(self.file_path,\
      \ 'w')\n\n    def work(self, input_items, output_items):\n        in_data =\
      \ input_items[0]   # Input data\n        out_data = output_items[0]  # Output\
      \ data\n\n        # Determine how many samples to process before reaching the\
      \ limit\n        remaining_samples = self.sample_limit - self.sample_count\n\
      \        n_samples = min(len(in_data), remaining_samples)\n\n        # Log data\
      \ to file\n        for i in range(n_samples):\n            self.file.write(f\"\
      {in_data[i].real}, {in_data[i].imag}\\n\")  # Write real and imaginary parts\n\
      \n        # Update sample count\n        self.sample_count += n_samples\n\n\
      \        # Pass through input to output for processed samples\n        out_data[:n_samples]\
      \ = in_data[:n_samples]\n\n        # Check if the sample limit has been reached\n\
      \        if self.sample_count >= self.sample_limit:\n            self.file.close()\
      \  # Close the file to ensure all data is written\n            return -1  #\
      \ Signal GNU Radio to stop processing\n\n        # Return the number of processed\
      \ samples\n        return n_samples\n\n    def __del__(self):\n        # Ensure\
      \ the file is closed properly if the block is deleted\n        if not self.file.closed:\n\
      \            self.file.close()\n"
    affinity: ''
    alias: ''
    comment: ''
    file_path: '"/home/samnolan/OSLA_research/OSLA/bpsk/interference/MATLAB/GRC_verification/waveform.csv"'
    maxoutbuf: '0'
    minoutbuf: '0'
    sample_limit: '1000000'
  states:
    _io_cache: ('Logging Block', 'logging_block', [('file_path', "'output.log'"),
      ('sample_limit', '1000')], [('0', 'complex', 1)], [('0', 'complex', 1)], '\n    Logs
      complex input data to a file and stops processing after a specified number of
      samples.\n    Signals the GNU Radio runtime to terminate by returning -1 once
      the sample limit is reached.\n    ', ['file_path', 'sample_limit'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [688, 212.0]
    rotation: 0
    state: true
- name: epy_block_2_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass logging_block(gr.sync_block):\n\
      \    \"\"\"\n    Logs complex input data to a file and stops processing after\
      \ a specified number of samples.\n    Signals the GNU Radio runtime to terminate\
      \ by returning -1 once the sample limit is reached.\n    \"\"\"\n    def __init__(self,\
      \ file_path=\"output.log\", sample_limit=1000):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"Logging Block\",\n            in_sig=[np.int32],\
      \  # Input: complex data\n            out_sig=[np.int32]  # Output: complex\
      \ data\n        )\n        self.file_path = file_path\n        self.sample_limit\
      \ = sample_limit\n        self.sample_count = 0\n        self.file = open(self.file_path,\
      \ 'w')\n\n    def work(self, input_items, output_items):\n        in_data =\
      \ input_items[0]   # Input data\n        out_data = output_items[0]  # Output\
      \ data\n\n        # Determine how many samples to process before reaching the\
      \ limit\n        remaining_samples = self.sample_limit - self.sample_count\n\
      \        n_samples = min(len(in_data), remaining_samples)\n\n        # Log data\
      \ to file\n        for i in range(n_samples):\n            self.file.write(f\"\
      {in_data[i]}\\n\")  # Write real and imaginary parts\n\n        # Update sample\
      \ count\n        self.sample_count += n_samples\n\n        # Pass through input\
      \ to output for processed samples\n        out_data[:n_samples] = in_data[:n_samples]\n\
      \n        # Check if the sample limit has been reached\n        if self.sample_count\
      \ >= self.sample_limit:\n            self.file.close()  # Close the file to\
      \ ensure all data is written\n            return -1  # Signal GNU Radio to stop\
      \ processing\n\n        # Return the number of processed samples\n        return\
      \ n_samples\n\n    def __del__(self):\n        # Ensure the file is closed properly\
      \ if the block is deleted\n        if not self.file.closed:\n            self.file.close()\n"
    affinity: ''
    alias: ''
    comment: ''
    file_path: '"/home/samnolan/OSLA_research/OSLA/bpsk/interference/MATLAB/GRC_verification/interarrival_times.csv"'
    maxoutbuf: '0'
    minoutbuf: '0'
    sample_limit: '1000000'
  states:
    _io_cache: ('Logging Block', 'logging_block', [('file_path', "'output.log'"),
      ('sample_limit', '1000')], [('0', 'int', 1)], [('0', 'int', 1)], '\n    Logs
      complex input data to a file and stops processing after a specified number of
      samples.\n    Signals the GNU Radio runtime to terminate by returning -1 once
      the sample limit is reached.\n    ', ['file_path', 'sample_limit'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [744, 412.0]
    rotation: 0
    state: true
- name: import_0
  id: import
  parameters:
    alias: ''
    comment: ''
    imports: import math
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [552, 20.0]
    rotation: 0
    state: true
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: '500000'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.1'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [968, 116.0]
    rotation: 0
    state: true

connections:
- [analog_random_source_x_0, '0', digital_gfsk_mod_0_0_0, '0']
- [analog_random_source_x_0_0, '0', digital_gfsk_mod_0_0_0_0, '0']
- [analog_random_source_x_0_1, '0', digital_gfsk_mod_0_0_0_1, '0']
- [blocks_throttle_0, '0', qtgui_time_sink_x_0, '0']
- [digital_gfsk_mod_0_0_0, '0', epy_block_0, '0']
- [digital_gfsk_mod_0_0_0_0, '0', epy_block_0, '1']
- [digital_gfsk_mod_0_0_0_1, '0', epy_block_0, '2']
- [epy_block_0, '0', epy_block_2, '0']
- [epy_block_0, '1', epy_block_2_0, '0']
- [epy_block_0, Debug, blocks_message_debug_0, print]
- [epy_block_2, '0', blocks_throttle_0, '0']
- [epy_block_2_0, '0', blocks_throttle_0_0, '0']

metadata:
  file_format: 1
